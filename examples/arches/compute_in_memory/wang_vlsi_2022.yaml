# @INPROCEEDINGS{9830322,
#   author={Wang, Hechen and Liu, Renzhi and Dorrance, Richard and Dasalukunte, Deepak and Liu, Xiaosen and Lake, Dan and Carlton, Brent and Wu, May},
#   booktitle={2022 IEEE Symposium on VLSI Technology and Circuits (VLSI Technology and Circuits)},
#   title={A 32.2 TOPS/W SRAM Compute-in-Memory Macro Employing a Linear 8b C-2C Ladder for Charge Domain Computation in 22nm for Edge Inference},
#   year={2022},
#   volume={},
#   number={},
#   pages={36-37},
#   doi={10.1109/VLSITechnologyandCir46769.2022.9830322}}
#
# @ARTICLE{10008405,
#   author={Wang, Hechen and Liu, Renzhi and Dorrance, Richard and Dasalukunte, Deepak and Lake, Dan and Carlton, Brent},
#   journal={IEEE Journal of Solid-State Circuits},
#   title={A Charge Domain SRAM Compute-in-Memory Macro With C-2C Ladder-Based 8b MAC Unit in 22-nm FinFET Process for Edge Inference},
#   year={2023},
#   volume={58},
#   number={4},
#   pages={1037-1050},
#   doi={10.1109/JSSC.2022.3232601}}

{{include_text('_include.yaml')}}
{{add_to_path('./memory_cells')}}

arch:
  variables:
    <<: *variables_global

    # ===========================================================================
    # Encoding-dependent parameters
    # ===========================================================================
    encoded_input_bits:  input_bits
    encoded_weight_bits: weight_bits
    encoded_output_bits: output_bits

    input_encoding_func: offset_encode_hist
    weight_encoding_func: offset_encode_hist

    # For accuracy model. Can in-array accumulation include signed values?
    # Signed accumulation not compatible with offset encoding (since offset
    # encoding makes values non-negative).
    signed_sum_across_inputs: True
    signed_sum_across_weights: False

    # ===========================================================================
    # Architecture & CiM Array Structure
    # ===========================================================================
    # DEFINITIONS:
    # - Cell: Smallest structure capable of storing memory. Note that a cell may
    #         store more than one bit. For example, a cell consisting of a RRAM
    #         device may store >1 bits, while a cell consisting of an SRAM
    #         bitcell may store only 1 bit.
    # - CiM Unit: Smallest structure capable of computing an analog MAC.
    # - CiM Unit Width Cells:
    #     Number of CiM unit cells that are accessed as one. These cells receive
    #     one analog input and compute one analog MAC per timestep.
    # - CiM Unit Depth Cells:
    #     Number of independent groups of "CiM Unit Width" cells that form a CiM
    #     unit. Each of these groups is indepently addressible and operates in
    #     must be activated in a different timestep than the others.

    cim_unit_width_cells:  supported_weight_bits
    cim_unit_depth_cells:  8
    bits_per_cell:         1

    # ===========================================================================
    # Data Converters
    # ===========================================================================
    adc_resolution: 8
    voltage_dac_resolution: 8
    temporal_dac_resolution: 1
    dac_unit_resistance: 5000

    n_adc_per_bank: 16

    # ===========================================================================
    # Hardware
    # ===========================================================================
    base_latency: 6.4e-9
    latency_columns_scale: dac_unit_resistance / 5000 * array_bitlines / 128
    latency_dac_resolution_scale: voltage_dac_resolution / 8
    # Digital clock runs at 2x analog clock speed. Don't let analog clock go
    # faster than that
    no_faster_than_digital: max(0.5, latency_columns_scale * latency_dac_resolution_scale)
    # Assume temporal DAC runs no faster than 0.05ns/step
    limited_by_temporal_dac: 0.05e-9 * (2 ** temporal_dac_resolution - 1)
    cycle_period: max(base_latency * no_faster_than_digital * voltage_latency_scale, limited_by_temporal_dac, 2e-9)
    read_pulse_width: cycle_period

  extra_attributes_for_all_component_models:
    <<: *cim_component_attributes
    tech_node: tech_node
    cycle_period: cycle_period

  nodes:
  - !Toll # DAC converts digital inputs to analog voltages
    name: DAC
    tensors: {keep: input}
    direction: down
    bits_per_action: input_bits / n_input_slices # n_input_slices reads to send an input
    component_class: DualSidedR2RLadderDAC
    n_parallel_instances: array_parallel_inputs # One DAC for each row
    extra_attributes_for_component_model:
      resolution: dac_resolution
      unit_resistance: dac_unit_resistance
      zero_between_values: 0
      bit_distribution: input_bit_distribution
      hist: hist_to_magnitude(inputs_hist)

  - !Toll # Row drivers feed inputs onto the rows of the array
    name: RowDrivers
    tensors: {keep: input}
    direction: down
    bits_per_action: input_bits / n_input_slices # n_input_slices reads to send an input
    component_class: ArrayRowDrivers

  - !Toll # Weight drivers write weights to the array
    name: WeightDrivers
    tensors: {keep: weight & Above} # Only program the weights if they're not backed in the CiM units
    direction: down
    component_class: ArrayRowDrivers
    bits_per_action: weight_bits / n_weight_slices # n_weight_slices writes to send a weight
    extra_attributes_for_component_model: {<<: [*weight_drivers_attributes]}

  - !Toll # Select different sets of weights each timestep
    name: SelectWordlineDrivers
    tensors: {keep: input}
    direction: down
    bits_per_action: input_bits / n_input_slices # n_input_slices reads to send an input
    component_class: ArrayRowDrivers
    extra_attributes_for_component_model:
      # Unlike normal row drivers, this is always fully asserted to select a row
      average_input_value: 1

  - !Toll # Column readout (ADC)
    name: ADC
    tensors: {keep: output}
    direction: up
    component_class: ADC
    bits_per_action: output_bits / n_sliced_psums
    energy_scale: adc_energy_scale
    area_scale: adc_area_scale
    extra_attributes_for_component_model:
      n_bits: adc_resolution
      throughput_scale: 1 # 1 cycle to process all outputs
      throughput: 1 / cycle_period * cols_active_at_once * throughput_scale

  - !Toll # Column drivers
    name: ColumnDrivers
    tensors: {keep: output}
    direction: up
    component_class: ArrayColumnDrivers
    bits_per_action: output_bits / n_sliced_psums
    actions: [{name: read, latency: cycle_period / cols_active_at_once}]

  - !Container
    name: ColumnOfSubBanks
    spatial:
    - name: array_reuse_input # Special name that determines array size
      fanout: 16
      usage_scale: n_weight_slices
      reuse: input
      min_usage: 1

  # Column bandwidth limiter to limit write speed (only one value can be written per
  # column per cycle)
  - !Toll
    name: ColumnBandwidthLimiter
    # Keep weight and output tensors. Don't keep anything if it doesn't leave the array.
    tensors: {keep: (weight | output) & Above}
    direction: down
    component_class: Dummy

    # Each time a weight slice is written to the array, consume 0.5 "bits". 0.5 because
    # the digital clock (writing weights) runs at 2x the speed of the analog clock. Each
    # time a sliced psum is read from the array, consume 1 "bit"
    bits_per_value_scale:
      weight: n_weight_slices / weight_bits / 2
      output: n_sliced_psums / output_bits
      All - (weight | output): 0 # Don't care

    # One cycle period per "bit"
    actions: [{name: read, latency: cycle_period}]

  - !Container # Each sub-bank receives a different input slice. Sub-banks share outputs.
    name: SubBank
    spatial:
    - name: array_reuse_output # Special name that determines array size
      fanout: 64
      reuse: output
      min_usage: 1

  # This is the CiM unit that stores weights and computes MACs. Each CiM unit stores a
  # different weight slice of up to cim_unit_width_cells bits. It may also store up to
  # cim_unit_depth_cells independently-addressable weight slices, but may only compute
  # MACs on one slice at a time. One of these components represents a collection of CiM
  # units, that together hold one weight.
  - !Memory
    name: CimUnit
    component_class: MemoryCell
    size: cim_unit_width_cells * cim_unit_depth_cells * bits_per_cell * n_weight_slices
    # Requires (n_weight_slices * n_input_slices) computes to fully use one weight
    bits_per_action: weight.bits_per_value / n_weight_slices / n_input_slices
    # Bind together n_weight_slices instances to hold one weight
    n_parallel_instances: n_weight_slices
    extra_attributes_for_component_model:
      n_instances: cim_unit_width_cells * cim_unit_depth_cells
    tensors: {keep: weight, no_refetch_from_above: weight, force_memory_hierarchy_order: False}
    # NeuroSim-returned results are too high for this component, so override the latency
    actions: [{name: read, latency: cycle_period}]

  - !Toll # Digital port of the C-2C multiplier. Weights enter here.
    name: C2CMultiplier
    tensors: {keep: input}
    direction: down
    component_class: C2CMultiplier
    # Requires (n_weight_slices * n_input_slices) computes to fully use one weight
    bits_per_action: input.bits_per_value / n_weight_slices / n_input_slices
    extra_attributes_for_component_model: &c2c_params
      resolution:           cim_unit_width_cells
      a_hist:               inputs_hist
      b_bit_distribution:   weight_bit_distribution
      unit_capacitance:     2e-15

  - !Toll # Analog port of the C-2C multiplier. Inputs enter here.
    name: C2CMultiplierPortB
    tensors: {keep: weight}
    direction: down
    component_class: C2CMultiplierPortB
    # Accessed n_sliced_psums times to fully read out a weight and create a psum with it
    bits_per_action: weight.bits_per_value / n_sliced_psums
    extra_attributes_for_component_model: *c2c_params

  # We account for compute energy in the CimUnit reads
  - !Compute
    name: FreeCompute
    component_class: Dummy
    enabled: len(All) == 3

# These variables pertain to the workload, microarch, and circuits. They should
# be matched between architectures when comparing for a fair comparison.
# Furthermore, this file should follow the same format for all architectures
# such that we can mix and match architectures with different iso files.
variables:
  # ===========================================================================
  # Workload, microarch, circuits. Things that should be matched
  # between architectures when comparing.
  # ===========================================================================
  # Set by CiM processor if these values are available in the workload.
  # Otherwise, use the defaults here.
  inputs_hist: [1, 2, 3, 4, 3, 2, 1]
  weights_hist: [1, 1, 1, 1, 1, 1, 1]
  outputs_hist: inputs_hist

  ## Microarch ----------------------------------------------------------------
  supported_input_bits:  8       # Maximum input bits supported by the arch.
  supported_weight_bits: 8       # Maximum weight bits supported by the arch.
  supported_output_bits: 8       # Maximum output bits supported by the arch.
  min_supported_input_bits: 8    # Minimum input bits supported by the arch.
  min_supported_weight_bits: 8   # Minimum weight bits supported by the arch.
  min_supported_output_bits: 8   # Minimum output bits supported by the arch.

  # Circuits ------------------------------------------------------------------
  voltage: 1
  tech_node: 22e-9 # nm
  cell_config: "{{find_path('sram_wang_vlsi_2022.yaml')}}"
  voltage_energy_scale: (voltage / 1) ** 2
  voltage_latency_scale: (0.7 / voltage) ** 1.1

  # Calibration ---------------------------------------------------------------
  adc_energy_scale: 3.6 * voltage_energy_scale
  adc_area_scale: 0.4
  row_col_drivers_area_scale: 1


# This workload is sized to get peak throughput & energy efficiency.
workload:
  rank_sizes:
    M: 1
    N: 16
    K: 64
    B: 1

  einsums:
  - name: Matmul
    tensor_accesses:
    - {name: input, projection: [b, m, k], bits_per_value: 8}
    - {name: weight, projection: [b, k, n], bits_per_value: 8}
    - {name: output, projection: [b, m, n], output: True, bits_per_value: 8}
renames: {} # Not needed for this workload
